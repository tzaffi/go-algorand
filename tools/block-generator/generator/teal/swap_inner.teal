// SOURCE: https://algoscan.app/app/1000459750
#pragma version 8

// intcblock 1 1000451837 0 2 1000451867 4 10000 3 5 32 // <-- original intcblock
intcblock 1 {{.AssetID1}} 0 2 {{.AssetID2}} 4 10000 3 5 32

bytecblock 0x41 0x42 0x4c 0x4c544944 0x41444d494e 0x5452454153555259 0x4645455f425053 0x504143545f4645455f425053 0x 0x3f 0x52228660325f087e5214a182e3725d8ac314bd2ae2cdc908b2f02ead60501d16
txn RekeyTo // AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
global ZeroAddress
==
txna Assets 0
intc_1 // AssetID1
==
&&
txna Assets 1
intc 4 // AssetID2
==
&&
txn NumAssets
intc 7 // 3
<=
&&
txn NumAssets
intc 7 // 3
==
bnz label1 // when len(Assets) == 3 -> thirdAssetIsLTID() -> label62

intc_0 // 1
label62:

	&&
	txn OnCompletion
	intc_2 // 0
	==
	&&
	!
	// TODO: allow OptInOC == 1 as well!!!!
	bnz label2 // when not NoOpOC ... fail the txn

	txn ApplicationID // id=0
	intc_2 // 0
	==
	bnz label3 // CASE CREATE THIS APP. Set 7 global uints and 4 bytes // added for block-generator: also opt-in to to intc_1 and intc 4

	txna ApplicationArgs 0
	pushbytes 0x4f5054494e // "OPTIN" (to this app's assets???, NOT to the app!!!)
	==
	bnz label4 // CASE OPTIN ASSETS

	txna ApplicationArgs 0
	pushbytes 0x434c54 // "CLT" = Create Liquidity Token
	==
	bnz label5 // CASE CREATE LIQUIDITY TOKEN

	txna ApplicationArgs 0
	pushbytes 0x53574150 // "SWAP"
	==
	bnz label6 // CASE OUTER APP SWAP CALL!!!!

	txna ApplicationArgs 0
	pushbytes 0x4144444c4951 // "ADDLIQ"
	==
	bnz label7 // CASE ADDING LIQUIDITY

	txna ApplicationArgs 0
	pushbytes 0x52454d4c4951 // "REMLIQ"
	==
	bnz label8

	txna ApplicationArgs 0
	pushbytes 0x574954484452415746454553 // "WITHDRAWFEES"
	==
	bnz label9

	txna ApplicationArgs 0
	pushbytes 0x4348414e47455f41444d494e // "CHANGE_ADMIN"
	==
	bnz label10

	txna ApplicationArgs 0
	pushbytes 0x4348414e47455f5452454153555259 // "CHANGE_TREASURY"
	==
	bnz label11

	txna ApplicationArgs 0
	pushbytes 0x4348414e47455f504143545f464545 // "CHANGE_PACT_FEE"
	==
	bnz label12
	err

label12:

	txn Sender // SWAPVMWRFIIY2L5V2JEWXIE7TLSOCUJP4BJYMAM65VBMRXHHE24GBMMPYM
	bytec 4 // "ADMIN"
	app_global_get
	==
	assert

	txna ApplicationArgs 1
	btoi
	bytec 6 // "FEE_BPS"
	app_global_get
	intc_3 // 2
	/
	<=
	assert

	bytec 7 // "PACT_FEE_BPS"
	txna ApplicationArgs 1
	btoi
	app_global_put

	intc_0 // 1
	return

label11:

	txn Sender // SWAPVMWRFIIY2L5V2JEWXIE7TLSOCUJP4BJYMAM65VBMRXHHE24GBMMPYM
	bytec 4 // "ADMIN"
	app_global_get
	==
	assert

	txna Accounts 1
	len
	intc 9 // 32
	==
	assert

	bytec 5 // "TREASURY"
	txna Accounts 1
	app_global_put

	intc_0 // 1
	return

label10:

	txn Sender // SWAPVMWRFIIY2L5V2JEWXIE7TLSOCUJP4BJYMAM65VBMRXHHE24GBMMPYM
	bytec 4 // "ADMIN"
	app_global_get
	==
	assert

	txna Accounts 1
	len
	intc 9 // 32
	==
	assert

	bytec 4 // "ADMIN"
	txna Accounts 1
	app_global_put

	intc_0 // 1
	return

label9:

	bytec 5 // "TREASURY"
	app_global_get
	intc_1 // AssetID1
	intc_1 // AssetID1
	bnz label13

	global CurrentApplicationAddress
	balance
	global CurrentApplicationAddress
	min_balance
	-
label23:

	bytec_0 // "A"
	app_global_get
	<
	bnz label14

	intc_1 // AssetID1
	bnz label15

	global CurrentApplicationAddress
	balance
	global CurrentApplicationAddress
	min_balance
	-
label21:

	bytec_0 // "A"
	app_global_get
	-
label22:

	callsub label16

	bytec 5 // "TREASURY"
	app_global_get
	intc 4 // AssetID2
	global CurrentApplicationAddress
	intc 4 // AssetID2
	asset_holding_get AssetBalance
	store 29
	store 28

	load 28
	bytec_1 // "B"
	app_global_get
	<
	bnz label17

	global CurrentApplicationAddress
	intc 4 // AssetID2
	asset_holding_get AssetBalance
	store 29
	store 28

	load 28
	bytec_1 // "B"
	app_global_get
	-
label20:

	callsub label16

	intc_1 // AssetID1
	bnz label18

label19:

	intc_0 // 1
	return

label18:

	bytec 5 // "TREASURY"
	app_global_get
	intc_2 // 0
	global CurrentApplicationAddress
	balance
	global CurrentApplicationAddress
	min_balance
	-
	callsub label16
	b label19

label17:

	intc_2 // 0
	b label20

label15:

	global CurrentApplicationAddress
	intc_1 // AssetID1
	asset_holding_get AssetBalance
	store 27
	store 26

	load 26
	b label21

label14:

	intc_2 // 0
	b label22

label13:

	global CurrentApplicationAddress
	intc_1 // AssetID1
	asset_holding_get AssetBalance
	store 27
	store 26

	load 26
	b label23

label8:

	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns TypeEnum
	intc 5 // 4
	==
	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns RekeyTo
	global ZeroAddress
	==
	&&
	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns AssetCloseTo
	global ZeroAddress
	==
	&&
	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns XferAsset
	bytec_3 // "LTID" == Liquidity Token ID
	app_global_get
	==
	&&
	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==
	&&
	assert

	bytec_2 // "L"
	app_global_get
	intc_2 // 0
	!=
	assert

	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns AssetAmount
	bytec_0 // "A"
	app_global_get
	mulw
	bytec_2 // "L"
	app_global_get
	divw
	store 24

	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns AssetAmount
	bytec_1 // "B"
	app_global_get
	mulw
	bytec_2 // "L"
	app_global_get
	divw
	store 25

	bytec_0 // "A"
	bytec_0 // "A"
	app_global_get
	load 24
	-
	app_global_put

	bytec_1 // "B"
	bytec_1 // "B"
	app_global_get
	load 25
	-
	app_global_put

	bytec_2 // "L"
	bytec_2 // "L"
	app_global_get
	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns AssetAmount
	-
	app_global_put

	load 25
	txna ApplicationArgs 2
	btoi
	-
	pop
	load 24
	txna ApplicationArgs 1
	btoi
	-
	pop
	intc_1 // AssetID1
	load 24
	callsub label24

	intc 4 // AssetID2
	load 25
	callsub label24

	intc_0 // 1
	return

label7: // CASE ADD LIQUIIDITY

	bytec_3 // "LTID"
	app_global_get // "LTID"
	assert

	intc_1 // AssetID1
	!
	bnz label25 // if AssetID1 not defined, go to label25 ~ provideAlgoVsASALiquidity()

	// txn[gpIdx-2] is an axfer of AssetID1 to this appAddress
	txn GroupIndex // index=1

	intc_3 // 2
	-
	gtxns TypeEnum
	intc 5 // 4
	==
	txn GroupIndex // index=1
	intc_3 // 2
	-
	gtxns RekeyTo
	global ZeroAddress
	==
	&&
	txn GroupIndex // index=1
	intc_3 // 2
	-
	gtxns AssetCloseTo
	global ZeroAddress
	==
	&&
	txn GroupIndex // index=1
	intc_3 // 2
	-
	gtxns XferAsset
	intc_1 // AssetID1
	==
	&&
	txn GroupIndex // index=1
	intc_3 // 2
	-
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==
	&&
label44:

	assert

	// txn[gpIdx-1] is an axfer of AssetID2 to this appAddress
	txn GroupIndex // index=1

	intc_0 // 1
	-
	gtxns TypeEnum
	intc 5 // 4
	==
	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns RekeyTo
	global ZeroAddress
	==
	&&
	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns AssetCloseTo
	global ZeroAddress
	==
	&&
	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns XferAsset
	intc 4 // AssetID2
	==
	&&
	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==
	&&
	assert

	bytec_2 // "L"
	app_global_get
	intc_2 // 0
	==
	bnz label26 // the first time called, global["L"] == 0 and go to label26

	intc_1 // AssetID1
	!
	bnz label27

	txn GroupIndex // index=1
	intc_3 // 2
	-
	gtxns AssetAmount
label39:

	bytec_2 // "L"
	app_global_get
	mulw
	bytec_0 // "A"
	app_global_get
	divw
	store 17

	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns AssetAmount
	bytec_2 // "L"
	app_global_get
	mulw
	bytec_1 // "B"
	app_global_get
	divw
	store 18

	load 17
	load 18
	dup2
	>
	select
	txna ApplicationArgs 1
	btoi
	-
	pop
	load 17
	load 18
	dup2
	>
	select
	intc_2 // 0
	>
	assert

	bytec_3 // "LTID"
	app_global_get
	load 17
	load 18
	dup2
	>
	select
	callsub label24

	bytec_2 // "L"
	bytec_2 // "L"
	app_global_get
	load 17
	load 18
	dup2
	>
	select
	+
	app_global_put

	load 17
	load 18
	>
	bnz label28

	load 17
	load 18
	<
	bnz label29

	bytec_0 // "A"
	bytec_0 // "A"
	app_global_get
	intc_1 // AssetID1
	!
	bnz label30

	txn GroupIndex // index=1
	intc_3 // 2
	-
	gtxns AssetAmount
label31:

	+
	app_global_put

	bytec_1 // "B"
	bytec_1 // "B"
	app_global_get
	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns AssetAmount
	+
	app_global_put

label34:

	intc_0 // 1
	return

label30:

	txn GroupIndex // index=1
	intc_3 // 2
	-
	gtxns Amount
	b label31

label29:

	bytec_1 // "B"
	app_global_get
	store 21

	bytec_1 // "B"
	bytec_1 // "B"
	app_global_get
	intc_1 // AssetID1
	!
	bnz label32

	txn GroupIndex // index=1
	intc_3 // 2
	-
	gtxns AssetAmount
label36:

	bytec_1 // "B"
	app_global_get
	mulw
	intc_2 // 0
	bytec_0 // "A"
	app_global_get
	divmodw
	||
	+
	swap
	!
	assert

	+
	app_global_put

	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns AssetAmount
	bytec_1 // "B"
	app_global_get
	load 21
	-
	-
	store 23

	intc 4 // AssetID2
	load 23
	callsub label24

	bytec_0 // "A"
	bytec_0 // "A"
	app_global_get
	intc_1 // AssetID1
	!
	bnz label33

	txn GroupIndex // index=1
	intc_3 // 2
	-
	gtxns AssetAmount
label35:

	+
	app_global_put
	b label34

label33:

	txn GroupIndex // index=1
	intc_3 // 2
	-
	gtxns Amount
	b label35

label32:

	txn GroupIndex // index=1
	intc_3 // 2
	-
	gtxns Amount
	b label36

label28:

	bytec_0 // "A"
	app_global_get
	store 20

	bytec_0 // "A"
	bytec_0 // "A"
	app_global_get
	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns AssetAmount
	bytec_0 // "A"
	app_global_get
	mulw
	intc_2 // 0
	bytec_1 // "B"
	app_global_get
	divmodw
	||
	+
	swap
	!
	assert

	+
	app_global_put

	intc_1 // AssetID1
	!
	bnz label37

	txn GroupIndex // index=1
	intc_3 // 2
	-
	gtxns AssetAmount
label38:

	bytec_0 // "A"
	app_global_get
	load 20
	-
	-
	store 22

	intc_1 // AssetID1
	load 22
	callsub label24

	bytec_1 // "B"
	bytec_1 // "B"
	app_global_get
	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns AssetAmount
	+
	app_global_put
	b label34

label37:

	txn GroupIndex // index=1
	intc_3 // 2
	-
	gtxns Amount
	b label38

label27:

	txn GroupIndex // index=1
	intc_3 // 2
	-
	gtxns Amount
	b label39

label26: // initialize L (the case that global["L"] == 0)

	intc_1 // AssetID1
	!
	bnz label40

	txn GroupIndex
	intc_3 // 2
	-
	gtxns AssetAmount
label43:

	itob				// bytes(AssetID1 amount)
	txn GroupIndex
	intc_0 // 1
	-
	gtxns AssetAmount
	itob				// stack->bytes(AssetID1 amount), bytes(AssetID2 amount)
	b*
	bsqrt
	btoi
	store 19			// 19 -> geometricMean(amount1, amount2)

	bytec_2 // "L"
	load 19
	app_global_put		// global["L"] = geometricMean(amount1, amount2)

	bytec_0 // "A"
	intc_1 // AssetID1
	!
	bnz label41			// in the case of Algos (instead of AssetID1), goto label41

	txn GroupIndex
	intc_3 // 2
	-
	gtxns AssetAmount
label42:

	app_global_put		// global["A"] = amount1

	bytec_1 // "B"
	txn GroupIndex
	intc_0 // 1
	-
	gtxns AssetAmount
	app_global_put		// global["B"] = amount2

	load 19
	pushint 1000
	-
	store 19			// slot[19] -= 1000 // i.e. geometricMean(amount1, amount2) - 1000

	load 19
	txna ApplicationArgs 1
	btoi
	>=
	assert				// amount1 >= arg1 + 1000

	bytec_3 // "LTID"
	app_global_get
	load 19
	callsub label24		// sendBackToCaller(appAssetID, geometricMean(amount1, amount2) - 1000)
	b label34

label41:

	txn GroupIndex // index=1
	intc_3 // 2
	-
	gtxns Amount
	b label42

label40:

	txn GroupIndex // index=1
	intc_3 // 2
	-
	gtxns Amount
	b label43

label25:

	txn GroupIndex
	intc_3 // 2
	-
	gtxns TypeEnum
	intc_0 // 1
	==  // txn[gpIdx-2] is a pay
	txn GroupIndex
	intc_3 // 2
	-
	gtxns RekeyTo
	global ZeroAddress
	==
	&&
	txn GroupIndex // index=1
	intc_3 // 2
	-
	gtxns CloseRemainderTo
	global ZeroAddress
	==
	&&
	txn GroupIndex // index=1
	intc_3 // 2
	-
	gtxns Receiver
	global CurrentApplicationAddress
	==
	&&
	b label44

label6: // SWAP CASE (and outer app call)

	intc_1 // AssetID1
	!
	bnz label45 // if forgot to set the assetID1 constant...

	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns TypeEnum
	intc 5 // 4
	==                          // previous txn is an axfer
	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns RekeyTo
	global ZeroAddress
	==                          // previous txn doesn't rekey
	&&
	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns AssetCloseTo
	global ZeroAddress
	==                          // previous txn doesn't closeout
	&&
	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns XferAsset
	intc_1 // AssetID1
	==                          // previous asset is assetID1
	&&
	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==                           // previous txn transfers to this app
	&&
label54:

	bnz label46                  // if all the previous...

	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns TypeEnum
	intc 5 // 4
	==
	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns RekeyTo
	global ZeroAddress
	==
	&&
	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns AssetCloseTo
	global ZeroAddress
	==
	&&
	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns XferAsset
	intc 4 // AssetID2
	==
	&&
	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==
	&&
	bnz label47

	intc_2 // 0
	return

// UNREACHABLE CODE:
// intc_0 // 1
// return
label47:

	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns AssetAmount
	bytec_0 // "A"
	app_global_get
	mulw
	bytec_1 // "B"
	app_global_get
	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns AssetAmount
	+
	divw
	store 14

	load 14
	bytec 7 // "PACT_FEE_BPS"
	app_global_get
	mulw
	intc 6 // 10000
	divw
	store 16

	load 14
	intc 6 // 10000
	bytec 6 // "FEE_BPS"
	app_global_get
	-
	mulw
	intc 6 // 10000
	divw
	store 15

	load 15
	txna ApplicationArgs 1
	btoi
	-
	pop
	bytec_0 // "A"
	bytec_0 // "A"
	app_global_get
	load 15
	-
	app_global_put

	bytec_0 // "A"
	bytec_0 // "A"
	app_global_get
	load 16
	-
	app_global_put

	bytec_1 // "B"
	bytec_1 // "B"
	app_global_get
	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns AssetAmount
	+
	app_global_put

	intc_1 // AssetID1
	load 15
	callsub label24

	intc_0 // 1
	return

label46: // CASE SWAP continued

	intc_1 // AssetID1
	!
	bnz label48                 // sanity check again...

	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns AssetAmount       // stack->prevGroupTxn.amount
label53:

	bytec_1 // "B"
	app_global_get          // stack->prevGroupTxn.amount,b
	mulw                    // prevGroupTxn.amount * b <<<hi1,lo1>>>
	bytec_0 // "A"
	app_global_get
	intc_1 // AssetID1    // stack->prevGroupTxn.amount * b, a, assetID1
	!
	bnz label49             // sanity check

	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns AssetAmount       // hi1, lo1, a, prevGroupTxn.amount
// in the following:
// LET P = prevGroupTxn.amount
// LET Q = 0.9995 * (b * P) / (a + P) // this is the 2nd asset amount
label52:

	+                       // hi1, lo1, a + prevGroupTxn.amount
	divw
	store 12                // 12 -> (b * P) / (a + P)

	load 12
	bytec 7 // "PACT_FEE_BPS"
	app_global_get
	mulw                    // (calc'n above) * pactFee
	intc 6 // 10000
	divw
	store 13                // 13 -> 0.0002 * (b * P) / (a + P)

	load 12
	intc 6 // 10000
	bytec 6 // "FEE_BPS"
	app_global_get          // stack->(b * P) / (a + P), 10000, 5
	-
	mulw
	intc 6 // 10000
	divw
	store 11                // 11 -> Q == 0.9995 * (b * P) / (a + P)

	load 11
	txna ApplicationArgs 1  // 0 in the case our outer app call
	btoi
	-                       // seemingly an sanity check... but we'll pass in our case
	pop
	bytec_1 // "B"
	bytec_1 // "B"
	app_global_get
	load 11                 // stack->"B", b, Q
	-
	app_global_put          // 1st update for "B": b -= Q

	bytec_1 // "B"
	bytec_1 // "B"
	app_global_get
	load 13                 // stack->"B", updated b, 0.0002 * (original b * P) / (a + P)
	-
	app_global_put          // 2nd update for "B": b -= 0.0002 * (original b * P) / (a + P)

	bytec_0 // "A"
	bytec_0 // "A"
	app_global_get
	intc_1 // AssetID1
	!
	bnz label50             // sanity check that we won't fall into

	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns AssetAmount       // stack->"A", a, P
label51:

	+
	app_global_put          // update "A": a += P

	intc 4 // AssetID2
	load 11                 // stack->appAssetID, Q
	callsub label24         // sendBackToCaller(appAssetID, Q)

	intc_0 // 1
	return

label50:

	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns Amount
	b label51

label49:

	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns Amount
	b label52

label48:

	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns Amount
	b label53

label45:

	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns TypeEnum
	intc_0 // 1
	==
	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns RekeyTo
	global ZeroAddress
	==
	&&
	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns CloseRemainderTo
	global ZeroAddress
	==
	&&
	txn GroupIndex // index=1
	intc_0 // 1
	-
	gtxns Receiver
	global CurrentApplicationAddress
	==
	&&
	b label54

	label5:  // CASE CLT (Create Liquidity Token)
	txn Sender // SWAPVMWRFIIY2L5V2JEWXIE7TLSOCUJP4BJYMAM65VBMRXHHE24GBMMPYM
	global CreatorAddress
	==
	assert

	bytec_3 // "LTID"
	app_global_get
	intc_2 // 0
	==
	assert				// can only create when there's 0

	intc_1 // AssetID1
	!
	bnz label55			// when first token is Algos, go to label55

	intc_1 // AssetID1
	asset_params_get AssetUnitName
	store 8							// 8 -> asset1NameExists?
	store 7							// 7 -> asset1Name

	load 7
	bytec 8 // ""
	==
	bnz label56						// when asset1Name is empty (i.e. Algos???), go to label56

	load 7
	store 5							// 5 -> asset1Name

// still CASE CLT (Create Liquidity Token)
label59:

	intc 4 // AssetID2
	asset_params_get AssetUnitName
	store 10
	store 9							// 9 -> asset2Name

	load 9
	bytec 8 // ""
	==
	bnz label57						// when asset2Name is empty (i.e. Algos???), go to label57

	load 9
	store 6							// 6 -> asset2Name

// still CASE CLT (Create Liquidity Token)
label58:

	// inner txn: acfg for the LTID asset: "asset1Name/asset2Name PACT LP Token" with URL https://pact.fi/
	itxn_begin

	intc_2 // 0
	itxn_field Fee
	intc 7 // 3
	itxn_field TypeEnum
	pushint 18446744073709551615  // max LTID supply is largest possible uint64
	itxn_field ConfigAssetTotal
	pushint 6
	itxn_field ConfigAssetDecimals
	load 5				// asset1Name
	pushbytes 0x2f 	// "/"
	concat
	load 6				// asset2Name
	concat
	pushbytes 0x2050414354204c5020546f6b656e // " PACT LP Token"
	concat
	itxn_field ConfigAssetName			// "[asset1Name]/[asset2Name] PACT LP Token"
	pushbytes 0x504c50 // "PLP"
	itxn_field ConfigAssetUnitName
	pushbytes 0x68747470733a2f2f706163742e66692f // "https://pact.fi/"
	itxn_field ConfigAssetURL
	global CurrentApplicationAddress
	itxn_field ConfigAssetReserve
	itxn_submit

	bytec_3 // "LTID"
	itxn CreatedAssetID
	app_global_put			// the only place (apart from init) where LTID is set

	intc_0 // 1
	return

label57:

	bytec 9 // "?"
	store 6
	b label58

label56:

	bytec 9 // "?"
	store 5
	b label59

label55:

	pushbytes 0x414c474f // "ALGO"
	store 5
	b label59

label4:

	txn Sender // SWAPVMWRFIIY2L5V2JEWXIE7TLSOCUJP4BJYMAM65VBMRXHHE24GBMMPYM
	global CreatorAddress
	==
	assert // only the creator can optin

	intc_1 // AssetID1
	!
	!
	bnz label60 // ALWAYS proceed to label60 (as in our case we're not swapping Algos for the first token)

label61: // optin to assetID2

	itxn_begin
	intc 5 // 4
	itxn_field TypeEnum
	global CurrentApplicationAddress
	itxn_field AssetReceiver
	intc_2 // 0
	itxn_field AssetAmount
	intc 4 // AssetID2
	itxn_field XferAsset
	intc_2 // 0
	itxn_field Fee
	itxn_submit

	intc_0 // 1
	return

label60: // optin to assetID1

	itxn_begin
	intc 5 // 4
	itxn_field TypeEnum                 // axfer
	global CurrentApplicationAddress
	itxn_field AssetReceiver            // to this app
	intc_2 // 0
	itxn_field AssetAmount              // the sender in will opt in to this app's asset
	intc_1 // AssetID1
	itxn_field XferAsset
	intc_2 // 0
	itxn_field Fee
	itxn_submit
	b label61 // proceed to second optin

label3: // CASE CREATE

	intc_1 // AssetID1
	intc 4 // AssetID2
	<
	assert // hardcoded/templatized ASA's are sorted

	intc 8 // 5
	intc 6 // 10000
	<
	assert // sanity check the AMM fee

	pushbytes 0x434f4e464947 // "CONFIG"
	intc_1 // AssetID1
	itob
	intc 4 // AssetID2
	itob
	concat
	intc 8 // 5
	itob
	concat
	app_global_put // global["10004518371000451867"] = "5"

	pushbytes 0x434f4e54524143545f4e414d45 // "CONTRACT_NAME"
	pushbytes 0x5041435420414d4d // "PACT AMM"
	app_global_put // global["CONTRACT_NAME"] = "PACT AMM"

	pushbytes 0x56455253494f4e // "VERSION"
	pushint 200
	app_global_put // global["VERSION"] = 200

	bytec_0 // "A"
	intc_2 // 0 // TODO: let's set this to something other than 0!!!
	app_global_put // global["A"] = 0 // var a

	bytec_1 // "B"
	intc_2 // 0 // TODO: let's set this to something other than 0!!!
	app_global_put // global["B"] = 0 // var b

	bytec_2 // "L"
	intc_2 // 0
	app_global_put // global["L"] = 0 // initial liquidity (L) is 0

	bytec_3 // "LTID"
	intc_2 // 0
	app_global_put // global["LTID"] = 0		// initialize the LTID as 0

	bytec 4 // "ADMIN"
	bytec 10 // addr KIRIMYBSL4EH4UQUUGBOG4S5RLBRJPJK4LG4SCFS6AXK2YCQDULANQH7V4
	app_global_put // global["ADMIN"] = "KIRIMYBSL4EH4UQUUGBOG4S5RLBRJPJK4LG4SCFS6AXK2YCQDULANQH7V4"

	bytec 5 // "TREASURY"
	bytec 10 // addr KIRIMYBSL4EH4UQUUGBOG4S5RLBRJPJK4LG4SCFS6AXK2YCQDULANQH7V4
	app_global_put // global["TREASURY"] = "KIRIMYBSL4EH4UQUUGBOG4S5RLBRJPJK4LG4SCFS6AXK2YCQDULANQH7V4"

	bytec 6 // "FEE_BPS"
	intc 8 // 5
	app_global_put // global["FEE_BPS"] = 5

	bytec 7 // "PACT_FEE_BPS"
	intc_3 // 2
	app_global_put // global["PACT_FEE_BPS"] = 2 // pactFee = 0.02%

	intc_0 // 1
	// return
	// added for block-generator:
	b label60

label2:

	intc_2 // 0
	return

// thirdAssetIsLTID()
label1:

	txna Assets 2
	bytec_3 // "LTID"
	app_global_get
	==
	b label62 // stack->globalStorage["LTID"]

// sendBackToCaller(appAssetID, Q)
label24:

	store 1     // 1 -> Q
	store 0     // 0 -> appAssetID

	load 0
	bnz label63 // always proceed since appAssetID never zero

	itxn_begin
	intc_0 // 1
	itxn_field TypeEnum
	txn Sender // SWAPVMWRFIIY2L5V2JEWXIE7TLSOCUJP4BJYMAM65VBMRXHHE24GBMMPYM
	itxn_field Receiver
	load 1
	itxn_field Amount
	intc_2 // 0
	itxn_field Fee
	itxn_submit
	b label64

label63: // always go here

	itxn_begin
	intc 5 // 4
	itxn_field TypeEnum
	txn Sender // SWAPVMWRFIIY2L5V2JEWXIE7TLSOCUJP4BJYMAM65VBMRXHHE24GBMMPYM
	itxn_field AssetReceiver    // send back to sender
	load 1
	itxn_field AssetAmount      // <-- Q
	load 0
	itxn_field XferAsset        // <-- appAssetID
	intc_2 // 0
	itxn_field Fee
	itxn_submit

label64:

	retsub // <-- caller of sendBackToCaller()

label16:

	store 4
	store 3
	store 2

	load 3
	bnz label65

	itxn_begin
	intc_0 // 1
	itxn_field TypeEnum
	load 2
	itxn_field Receiver
	load 4
	itxn_field Amount
	intc_2 // 0
	itxn_field Fee
	itxn_submit
	b label66

label65:

	itxn_begin
	intc 5 // 4
	itxn_field TypeEnum
	load 2
	itxn_field AssetReceiver
	load 4
	itxn_field AssetAmount
	load 3
	itxn_field XferAsset
	intc_2 // 0
	itxn_field Fee
	itxn_submit

label66:

	retsub

